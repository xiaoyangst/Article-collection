<html><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <meta name="format-detection" content="telephone=no, email=no">
    <title>C++20协程入门教程</title>
<style type="text/css">@font-face{font-family:Material Icons;font-style:normal;font-weight:400;src:url(material-icon.woff2) format("woff2")}md-note-flag{font-family:Material Icons;font-weight:400;font-style:normal;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:"liga";-webkit-font-smoothing:antialiased;font-size:.7em;vertical-align:top;user-select:none}:root{--reader-layout-max-width:800px;--reader-layout-width:min(100vw,var(--reader-layout-max-width))}@media screen and (max-width:800px){:root{--reader-layout-max-width:800px;--reader-layout-width:100vw}}@media screen and (min-width:800px){:root{--reader-layout-max-width:800px;--reader-layout-width:800px}}:root{--light-primary:#fff;--light-textColor:#000;--light-secondary-textColor:#a8a8a8;--dark-primary:#303030;--dark-textColor:#a0a0a8;--dark-secondary-textColor:#a1a1a1;--block-border-radius:5px;--reader-default-padding-left:28px;--reader-default-padding-right:28px;--reader-default-padding-top:40px;--reader-default-padding-bottom:40px;--reader-default-block-bg-color:rgba(48,48,48,0.05);--reader-default-block-left-border-color:rgba(48,48,48,0.3);--reader-bg-color:#fff;--reader-text-color:#000;--reader-secondary-text-color:#a8a8a8;--reader-link-color:#59a4d0;--reader-block-bg-color:#303030;--reader-block-left-border-color:#303030;--reader-padding-left:var(--reader-default-padding-left);--reader-padding-right:var(--reader-default-padding-right);--reader-padding-top:var(--reader-default-padding-top);--reader-padding-bottom:var(--reader-default-padding-bottom);--reader-page-gap:calc(var(--reader-padding-left) + var(--reader-padding-right));--reader-horizontal-img-max-height:calc(100vh - var(--reader-padding-top) - var(--reader-padding-bottom));--reader-horizontal-img-max-width:calc(var(--reader-layout-width) - var(--reader-page-gap));--reader-secondary-font-size:12px;--reader-paragraph-spacing:1em}.clearfix:after{content:"";clear:both;display:table}body{margin:0;font-size:15px;color:#000;color:var(--light-textColor);background-color:transparent;letter-spacing:1px;word-break:break-word;-webkit-font-smoothing:antialiased!important;-moz-osx-font-smoothing:antialiased!important}mdmark{cursor:pointer}.mandu-shl,.mandu-shl mdmark{background:#d3d600!important;border-radius:0}.mandu-shl.mandu-shl-focused,.mandu-shl.mandu-shl-focused mdmark{background:#a15f00!important}#_mandu_content_container{z-index:0}#_mandu_article_title{font-size:23px;font-weight:700;max-width:min(100vw,800px);max-width:var(--reader-layout-width)}@media screen and (min-width:800px){#_mandu_article_title{max-width:800px;max-width:var(--reader-layout-width)}}@media screen and (max-width:800px){#_mandu_article_title{max-width:100vw;max-width:var(--reader-layout-width)}}#_mandu_article_summary{max-width:min(100vw,800px);max-width:var(--reader-layout-width)}@media screen and (min-width:800px){#_mandu_article_summary{max-width:800px;max-width:var(--reader-layout-width)}}@media screen and (max-width:800px){#_mandu_article_summary{max-width:100vw;max-width:var(--reader-layout-width)}}#_mandu_article_content{max-width:min(100vw,800px);max-width:var(--reader-layout-width);overflow-x:auto;overflow-y:hidden}@media screen and (min-width:800px){#_mandu_article_content{max-width:800px;max-width:var(--reader-layout-width)}}@media screen and (max-width:800px){#_mandu_article_content{max-width:100vw;max-width:var(--reader-layout-width)}}p{overflow-x:auto;overflow-y:hidden}#_mandu_article_content div,#_mandu_article_content p,#_mandu_article_content section{margin-top:1em;margin-top:var(--reader-paragraph-spacing);margin-bottom:1em;margin-bottom:var(--reader-paragraph-spacing)}code{word-break:break-all;background-color:rgba(48,48,48,.05);background-color:var(--reader-default-block-bg-color);padding:1px 5px}code,pre{border-radius:5px;border-radius:var(--block-border-radius);letter-spacing:0}pre{overflow-x:auto;tab-size:2em}pre code{padding:18px}pre code:not([md-code-stage]){padding:0}blockquote,pre code:not([md-code-stage]){background-color:rgba(48,48,48,.05);background-color:var(--reader-default-block-bg-color)}blockquote{border-left:10px solid rgba(48,48,48,.3);border-left:10px solid var(--reader-default-block-left-border-color);border-radius:5px;border-radius:var(--block-border-radius);padding:.5em 10px;quotes:"\201C""\201D""\2018""\2019";margin:10px 0}blockquote:before{color:rgba(48,48,48,.3);color:var(--reader-default-block-left-border-color);content:open-quote;font-size:4em;line-height:.1em;margin-right:.1em;margin-left:-.3em;vertical-align:-.4em}blockquote,figcaption,h1,h2,h3,h4,h5,h6,li{text-indent:0}table{overflow-x:auto;border-collapse:collapse}table,table tr td,table tr th{border:1px solid #bbb}table:has(pre,code),table tr td:has(pre,code),table tr th:has(pre,code){border:none}td{padding:0 3px}td p{margin:0;padding:0}img.mandu-emoji{display:inline;height:1em;margin:0}img,video{max-width:100%;margin:15px auto;display:block}img{animation:fadeIn 1.2s ease;-webkit-animation:fadeIn 1.2s ease;-moz-animation:fadeIn ease 1.2s;-o-animation:fadeIn ease 1.2s;-ms-animation:fadeIn ease 1.2s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@-moz-keyframes fadeIn{0%{opacity:0}to{opacity:1}}@-webkit-keyframes fadeIn{0%{opacity:0}to{opacity:1}}@-o-keyframes fadeIn{0%{opacity:0}to{opacity:1}}@-ms-keyframes fadeIn{0%{opacity:0}to{opacity:1}}figure{margin:40px 0;display:block;max-width:100%;overflow-x:auto}figure img{margin:0 auto}figure figcaption{margin-top:12px;color:undefined;color:var(--secondary-textColor);font-size:12px;font-size:var(--reader-secondary-font-size)}a{color:#59a4d0;text-decoration:none}#_mandu_background{position:fixed;z-index:-10;right:0;left:0;bottom:0;top:0;transition:background-color 1.2s}#_mandu_background img{width:100%;height:100%;border:none;padding:0;margin:0}body.light{--primary:#fff;--primary:var(--light-primary);--onPrimary:#303030;--onPrimary:var(--dark-primary);--textColor:#000;--textColor:var(--light-textColor);--secondary-textColor:#a8a8a8;--secondary-textColor:var(--light-secondary-textColor);background-color:#fff;background-color:var(--primary);color:#000;color:var(--textColor)}body.light ::selection{background-color:#303030;background-color:var(--onPrimary);color:#fff;color:var(--primary)}body.light ._mandu_preload_font{color:#fff!important;color:var(--light-primary)!important}body.light{--reader-default-block-left-border-color:rgba(48,48,48,0.3);--reader-default-block-bg-color:rgba(48,48,48,0.05)}body.light #_mandu_background{background-color:#fff;background-color:var(--primary)}body.dark{--primary:#303030;--primary:var(--dark-primary);--onPrimary:#fff;--onPrimary:var(--light-primary);--textColor:#a0a0a8;--textColor:var(--dark-textColor);--secondary-textColor:#a1a1a1;--secondary-textColor:var(--dark-secondary-textColor);background-color:#303030;background-color:var(--primary);color:#a0a0a8;color:var(--textColor)}body.dark ::selection{background-color:#fff;background-color:var(--onPrimary);color:#303030;color:var(--primary)}body.dark ._mandu_preload_font{color:#fff!important;color:var(--light-primary)!important}body.dark{--reader-default-block-left-border-color:hsla(0,0%,100%,0.3);--reader-default-block-bg-color:hsla(0,0%,100%,0.05)}body.dark #_mandu_background{background-color:#303030;background-color:var(--primary)}body.customize{--secondary-textColor:var(--reader-secondary-text-color)}body.customize #_mandu_article_title{background:none}body.customize #_mandu_article_content{background-color:unset}body.customize #_mandu_content_container{position:relative}body.customize{color:#000;color:var(--reader-text-color)}body.customize a{color:#59a4d0;color:var(--reader-link-color)}body.customize ::selection{background-color:#000;background-color:var(--reader-text-color);color:#fff;color:var(--reader-bg-color)}body.customize blockquote,body.customize pre code:not([md-code-stage]){background-color:#303030;background-color:var(--reader-block-bg-color)}body.customize blockquote{border-left:10px solid #303030;border-left:10px solid var(--reader-block-left-border-color)}body.customize blockquote:before{color:#303030;color:var(--reader-block-left-border-color)}body.customize #_mandu_background{background-color:#fff!important;background-color:var(--reader-bg-color)!important}#_mandu_layout{box-sizing:border-box;max-width:800px;max-width:var(--reader-layout-max-width);margin:0 auto;padding:40px 28px;padding:var(--reader-default-padding-top) var(--reader-default-padding-right) var(--reader-default-padding-bottom) var(--reader-default-padding-left)}@media screen and (min-width:800px){#_mandu_layout{max-width:800px;max-width:var(--reader-layout-max-width)}}@media screen and (max-width:800px){#_mandu_layout{max-width:800px;max-width:var(--reader-layout-max-width)}}#_mandu_page_number{display:none}.customize #_mandu_layout{padding:40px 28px;padding:var(--reader-padding-top) var(--reader-padding-right) var(--reader-padding-bottom) var(--reader-padding-left)}.customize #_mandu_layout.horizontal{overflow-x:hidden}.customize #_mandu_layout.horizontal::-webkit-scrollbar{display:none}.customize #_mandu_layout.horizontal #_mandu_article_content{overflow-x:inherit;overflow-y:inherit}.customize #_mandu_layout.horizontal #_mandu_content_container{height:calc(100vh - 80px);height:calc(100vh - var(--reader-padding-top) - var(--reader-padding-bottom));width:calc(min(100vw, 800px) - 56px);width:calc(var(--reader-layout-width) - var(--reader-page-gap));column-width:calc(min(100vw, 800px) - 56px);column-width:calc(var(--reader-layout-width) - var(--reader-page-gap));column-gap:56px;column-gap:var(--reader-page-gap)}@media screen and (min-width:800px){.customize #_mandu_layout.horizontal #_mandu_content_container{column-width:744px;column-width:calc(var(--reader-layout-width) - var(--reader-page-gap))}}@media screen and (max-width:800px){.customize #_mandu_layout.horizontal #_mandu_content_container{column-width:calc(100vw - 56px);column-width:calc(var(--reader-layout-width) - var(--reader-page-gap))}}@media screen and (min-width:800px){.customize #_mandu_layout.horizontal #_mandu_content_container{width:744px;width:calc(var(--reader-layout-width) - var(--reader-page-gap))}}@media screen and (max-width:800px){.customize #_mandu_layout.horizontal #_mandu_content_container{width:calc(100vw - 56px);width:calc(var(--reader-layout-width) - var(--reader-page-gap))}}.customize #_mandu_layout.horizontal #_mandu_content_container video{display:none}.customize #_mandu_layout.horizontal #_mandu_content_container img{max-height:calc(100vh - 80px);max-height:var(--reader-horizontal-img-max-height);max-width:calc(min(100vw, 800px) - 56px);max-width:var(--reader-horizontal-img-max-width);height:auto;page-break-before:avoid;page-break-inside:avoid}@media screen and (min-width:800px){.customize #_mandu_layout.horizontal #_mandu_content_container img{max-width:744px;max-width:var(--reader-horizontal-img-max-width)}}@media screen and (max-width:800px){.customize #_mandu_layout.horizontal #_mandu_content_container img{max-width:calc(100vw - 56px);max-width:var(--reader-horizontal-img-max-width)}}.customize #_mandu_layout.horizontal #_mandu_content_container video{max-height:calc(100vh - 80px);max-height:var(--reader-horizontal-img-max-height);max-width:calc(min(100vw, 800px) - 56px);max-width:var(--reader-horizontal-img-max-width);height:auto;page-break-before:avoid;page-break-inside:avoid}@media screen and (min-width:800px){.customize #_mandu_layout.horizontal #_mandu_content_container video{max-width:744px;max-width:var(--reader-horizontal-img-max-width)}}@media screen and (max-width:800px){.customize #_mandu_layout.horizontal #_mandu_content_container video{max-width:calc(100vw - 56px);max-width:var(--reader-horizontal-img-max-width)}}.customize #_mandu_layout.horizontal #_mandu_page_number{display:block;letter-spacing:0;position:fixed;bottom:8px;right:12px;font-size:14px;font-family:system-ui;font-weight:400}details{border:undefined;border:1px solid var(--secondary-textColor);border-radius:4px;padding:.5em .5em 0;margin-bottom:.5em}summary{margin:-.5em -.5em 0;cursor:pointer}details[open],summary{padding:.5em}details[open] summary{border-bottom:undefined;border-bottom:1px solid var(--secondary-textColor);margin-bottom:.5em}p.mandu-equation{text-align:center}span.mandu-equation{margin-left:4px;margin-right:4px}mjx-assistive-mml{display:none}#_mandu_article_content.hide-images img{display:none!important}pre code.hljs{display:block;overflow-x:auto;padding:1em}.noscroll-code pre code{overflow-x:hidden;word-wrap:anywhere;white-space:pre-wrap}code.hljs{padding:3px 5px}.hljs[md-code-stage]{color:#adbac7;background:#22272e}.hljs[md-code-stage] .hljs-doctag,.hljs[md-code-stage] .hljs-keyword,.hljs[md-code-stage] .hljs-meta .hljs-keyword,.hljs[md-code-stage] .hljs-template-tag,.hljs[md-code-stage] .hljs-template-variable,.hljs[md-code-stage] .hljs-type,.hljs[md-code-stage] .hljs-variable.language_{color:#f47067}.hljs[md-code-stage] .hljs-title,.hljs[md-code-stage] .hljs-title.class_,.hljs[md-code-stage] .hljs-title.class_.inherited__,.hljs[md-code-stage] .hljs-title.function_{color:#dcbdfb}.hljs[md-code-stage] .hljs-attr,.hljs[md-code-stage] .hljs-attribute,.hljs[md-code-stage] .hljs-literal,.hljs[md-code-stage] .hljs-meta,.hljs[md-code-stage] .hljs-number,.hljs[md-code-stage] .hljs-operator,.hljs[md-code-stage] .hljs-selector-attr,.hljs[md-code-stage] .hljs-selector-class,.hljs[md-code-stage] .hljs-selector-id,.hljs[md-code-stage] .hljs-variable{color:#6cb6ff}.hljs[md-code-stage] .hljs-meta .hljs-string,.hljs[md-code-stage] .hljs-regexp,.hljs[md-code-stage] .hljs-string{color:#96d0ff}.hljs[md-code-stage] .hljs-built_in,.hljs[md-code-stage] .hljs-symbol{color:#f69d50}.hljs[md-code-stage] .hljs-code,.hljs[md-code-stage] .hljs-comment,.hljs[md-code-stage] .hljs-formula{color:#768390}.hljs[md-code-stage] .hljs-name,.hljs[md-code-stage] .hljs-quote,.hljs[md-code-stage] .hljs-selector-pseudo,.hljs[md-code-stage] .hljs-selector-tag{color:#8ddb8c}.hljs[md-code-stage] .hljs-subst{color:#adbac7}.hljs[md-code-stage] .hljs-section{color:#316dca;font-weight:700}.hljs[md-code-stage] .hljs-bullet{color:#eac55f}.hljs[md-code-stage] .hljs-emphasis{color:#adbac7;font-style:italic}.hljs[md-code-stage] .hljs-strong{color:#adbac7;font-weight:700}.hljs[md-code-stage] .hljs-addition{color:#b4f1b4;background-color:#1b4721}.hljs[md-code-stage] .hljs-deletion{color:#ffd8d3;background-color:#78191b}</style><style>mdmark.mdm-yellow {
                    border-radius: 3px;
                    color: #d9d9d9;
                    background-color: #7a6d0a;
                }
mdmark.mdm-red {
                    border-radius: 3px;
                    color: #d9d9d9;
                    background-color: #a71b0c;
                }
mdmark.mdm-qianniuzi {
                    border-radius: 3px;
                    color: #d9d9d9;
                    background-color: #8B2B72;
                }
mdmark.mdm-mantianxingzi {
                    border-radius: 3px;
                    color: #d9d9d9;
                    background-color: #35377e;
                }</style><style type="text/css">.CtxtMenu_InfoClose {  top:.2em; right:.2em;}
.CtxtMenu_InfoContent {  overflow:auto; text-align:left; font-size:80%;  padding:.4em .6em; border:1px inset; margin:1em 0px;  max-height:20em; max-width:30em; background-color:#EEEEEE;  white-space:normal;}
.CtxtMenu_Info.CtxtMenu_MousePost {outline:none;}
.CtxtMenu_Info {  position:fixed; left:50%; width:auto; text-align:center;  border:3px outset; padding:1em 2em; background-color:#DDDDDD;  color:black;  cursor:default; font-family:message-box; font-size:120%;  font-style:normal; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 15px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius:15px;               /* Safari and Chrome */  -moz-border-radius:15px;                  /* Firefox */  -khtml-border-radius:15px;                /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */  filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color="gray", Positive="true"); /* IE */}
</style><style type="text/css">.CtxtMenu_MenuClose {  position:absolute;  cursor:pointer;  display:inline-block;  border:2px solid #AAA;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  font-family: "Courier New", Courier;  font-size:24px;  color:#F0F0F0}
.CtxtMenu_MenuClose span {  display:block; background-color:#AAA; border:1.5px solid;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  line-height:0;  padding:8px 0 6px     /* may need to be browser-specific */}
.CtxtMenu_MenuClose:hover {  color:white!important;  border:2px solid #CCC!important}
.CtxtMenu_MenuClose:hover span {  background-color:#CCC!important}
.CtxtMenu_MenuClose:hover:focus {  outline:none}
</style><style type="text/css">.CtxtMenu_Menu {  position:absolute;  background-color:white;  color:black;  width:auto; padding:5px 0px;  border:1px solid #CCCCCC; margin:0; cursor:default;  font: menu; text-align:left; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 5px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius: 5px;             /* Safari and Chrome */  -moz-border-radius: 5px;                /* Firefox */  -khtml-border-radius: 5px;              /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */}
.CtxtMenu_MenuItem {  padding: 1px 2em;  background:transparent;}
.CtxtMenu_MenuArrow {  position:absolute; right:.5em; padding-top:.25em; color:#666666;  font-family: null; font-size: .75em}
.CtxtMenu_MenuActive .CtxtMenu_MenuArrow {color:white}
.CtxtMenu_MenuArrow.CtxtMenu_RTL {left:.5em; right:auto}
.CtxtMenu_MenuCheck {  position:absolute; left:.7em;  font-family: null}
.CtxtMenu_MenuCheck.CtxtMenu_RTL { right:.7em; left:auto }
.CtxtMenu_MenuRadioCheck {  position:absolute; left: .7em;}
.CtxtMenu_MenuRadioCheck.CtxtMenu_RTL {  right: .7em; left:auto}
.CtxtMenu_MenuInputBox {  padding-left: 1em; right:.5em; color:#666666;  font-family: null;}
.CtxtMenu_MenuInputBox.CtxtMenu_RTL {  left: .1em;}
.CtxtMenu_MenuComboBox {  left:.1em; padding-bottom:.5em;}
.CtxtMenu_MenuSlider {  left: .1em;}
.CtxtMenu_SliderValue {  position:absolute; right:.1em; padding-top:.25em; color:#333333;  font-size: .75em}
.CtxtMenu_SliderBar {  outline: none; background: #d3d3d3}
.CtxtMenu_MenuLabel {  padding: 1px 2em 3px 1.33em;  font-style:italic}
.CtxtMenu_MenuRule {  border-top: 1px solid #DDDDDD;  margin: 4px 3px;}
.CtxtMenu_MenuDisabled {  color:GrayText}
.CtxtMenu_MenuActive {  background-color: #606872;  color: white;}
.CtxtMenu_MenuDisabled:focus {  background-color: #E8E8E8}
.CtxtMenu_MenuLabel:focus {  background-color: #E8E8E8}
.CtxtMenu_ContextMenu:focus {  outline:none}
.CtxtMenu_ContextMenu .CtxtMenu_MenuItem:focus {  outline:none}
.CtxtMenu_SelectionMenu {  position:relative; float:left;  border-bottom: none; -webkit-box-shadow:none; -webkit-border-radius:0px; }
.CtxtMenu_SelectionItem {  padding-right: 1em;}
.CtxtMenu_Selection {  right: 40%; width:50%; }
.CtxtMenu_SelectionBox {  padding: 0em; max-height:20em; max-width: none;  background-color:#FFFFFF;}
.CtxtMenu_SelectionDivider {  clear: both; border-top: 2px solid #000000;}
.CtxtMenu_Menu .CtxtMenu_MenuClose {  top:-10px; left:-10px}
</style></head>
<body style="font-family: mandu, monospace;" class="light">
    
    <div id="_mandu_layout" onclick="void(0)">
        <div id="_mandu_content_container">
            <h2 id="_mandu_article_title">C++20协程入门教程</h2>
            <div id="_mandu_article_link"><a href="https://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/" target="_blank">原文链接</a></div>
            <div id="_mandu_article_summary" style="border-top: 1px solid rgba(128, 128, 128, 0.23); border-bottom: 1px solid rgba(128, 128, 128, 0.23); border-image: initial; border-left: none; border-right: none; padding: 8px 0px; display: none;">
                <div style="font-weight: bold;">本文摘要</div>
                <div id="_mandu_article_summary_content" style="padding: 10px 0;"></div>
                <div id="_mandu_article_summary_date" style="font-weight: bold; text-align: right; font-size: 12px;"></div>
            </div>
            <div id="_mandu_article_content"><div><h2>1. 前言</h2><p>随着Visual Studio 2022的发布，C++20终于来到了我们的眼前，在这个标准的新特性之中，最吸引人之一的是协程，对于饱受异步调用之繁琐写法的人来说，协程似乎是解决异步问题的灵丹妙药。</p><p>最初我对协程一无所知，当我开始学习它的时候，才发现它的复杂程度超出了我的预期。在网络上关于C++协程的文章有很多，但能够从初学者的角度把协程的基础原理讲清楚的寥寥无几。而且在<a href="http://cppreference.com/">cppreference.com</a>上关于协程的页面仍然是未完成的状态，不少组件的文档仍然是空缺的。</p><p>在这样的背景下，学习过程是比较曲折的。我阅读了各种不同的文章，运行并调试其中的示例代码，最终才理解了C++的协程是怎么回事。在这篇文章中，我将自己的学习经历作为参考，从入门的角度来介绍C++协程。希望这篇文章能帮助大家更容易学习和理解协程。</p><h2>2. 什么是协程</h2><p>学习协程遇到的第一个问题是：什么是协程？一个简短的回答是：协程是一个函数，它可以暂停以及恢复执行。按照我们对普通函数的理解，函数暂停意味着线程停止运行了（就像命中了断点一样），那协程的不同之处在哪里呢？区别在于，普通函数是线程相关的，函数的状态跟线程紧密关联；而协程是线程无关的，它的状态与任何线程都没有关系。</p><p>这个解释比较抽象，为了更好地理解，我们先来回顾一下函数的调用机制。在调用一个函数的时候，线程的栈上会记录这个函数的状态（参数、局部变量等），这是通过移动栈顶指针来完成的。例如，函数<code>Foo()</code>调用<code>Bar()</code>的过程如下所示：</p><img src="https://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/1.png"><p>首先，“地址3”到“地址2”这段空间，是分配给<code>Foo()</code>保存状态使用的，栈顶指针指向“地址2”；当调用<code>Bar()</code>的时候，栈顶指针移动到“地址1”，此时“地址2”到“地址1”这段空间是分配给<code>Bar()</code>保存状态使用的。当<code>Bar()</code>执行完毕，栈顶指针移动回“地址2”，<code>Bar()</code>的状态被销毁，内存空间被回收。</p><p>由此可见，函数状态的维护完全依赖于线程栈，脱离了线程，函数就不复存在，所以说函数是线程相关的。</p><p>而协程不一样，协程的状态是保存在堆内存上的。假设<code>Bar()</code>是一个协程，那么调用它的过程如下所示：</p><img src="https://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/2.png"><p>首先，<code>Bar()</code>的状态所需的内存会在堆上分配，独立于线程栈而存在。传递给它的参数都会复制到这个状态中，而局部变量会直接在这个状态中创建。调用<code>Bar()</code>的时候，由于本质上还是一个函数调用，所以栈顶指针也会往下移动，在栈上给执行<code>Bar()</code>所需的状态分配空间，其中会有一个引用指向在堆上的状态，这样一来，<code>Bar()</code>就可以像一个普通函数那样执行了，线程也可以访问到位于堆上的状态。</p><p>如果协程需要暂停，那么当前执行到的代码位置会记录到堆的状态中。然后栈上的执行时状态被销毁，栈顶指针移动以回收空间，就像普通函数结束时那样。在下一次恢复执行时，堆状态中记录的暂停位置会读取出来，从这个位置接着执行。这样就实现了一个可暂停和恢复执行的函数。</p><p>由此可见，当协程执行的时候，它跟普通函数一样，也是需要依赖线程栈；但是，一旦它暂停了，它的状态就会独立保存在堆中，此时它跟任何线程都没有关系，调用它的线程可以继续去做其它事情而不会停止。在下一次恢复执行时，协程可以由上次执行的线程来执行，也可以由另外一个完全不同的线程来执行。所以说协程是线程无关的。</p><h2>3. 协程的优点</h2><p>协程的优点主要在于，它能优化异步逻辑的代码，使代码可读性更高。举个例子，假设我们有一个组件叫<code>IntReader</code>，它的功能是从一个访问速度很慢的设备上读取一个整数值，因此它提供的接口是异步的，如下所示：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></pre></td><td><pre><span><span>class</span><span>IntReader</span>{</span><br><span><span>public</span>:</span><br><span><span><span>void</span><span>BeginRead</span><span>()</span></span>{</span><br><br><span>std::thread<span>thread</span><span>([]() {</span></span><br><br><span>std::srand(<span>static_cast</span>&lt;<span>unsigned</span><span>int</span>&gt;(std::time(<span>nullptr</span>)));</span><br><span><span>int</span>value = std::rand();</span><br><br><br><span><span>})</span>;</span><br><br><span>thread.<span>detach</span>();</span><br><span>}</span><br><span>};</span><br></pre></td></tr></tbody></table></figure><p><code>BeginRead()</code>开启了一个新的线程来生成一个随机的整数，模拟异步操作。作为一个仅用于示范的代码，这里尽量保持精简。</p><p>为了获取到<code>IntReader</code>的结果，传统的做法是提供一个回调函数，当操作完成的时候，通过回调函数告知使用者。如下所示：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></pre></td><td><pre><span><span>class</span><span>IntReader</span>{</span><br><span><span>public</span>:</span><br><span><span><span>void</span><span>BeginRead</span><span>(<span>const</span>std::function&lt;<span>void</span>(<span>int</span>)&gt;&amp; callback)</span></span>{</span><br><br><span>std::thread<span>thread</span><span>([callback]() {</span></span><br><br><span>std::srand(<span>static_cast</span>&lt;<span>unsigned</span><span>int</span>&gt;(std::time(<span>nullptr</span>)));</span><br><span><span>int</span>value = std::rand();</span><br><br><span>callback(value);</span><br><span><span>})</span>;</span><br><br><span>thread.<span>detach</span>();</span><br><span>}</span><br><span>};</span><br><br><span><span><span>void</span><span>PrintInt</span><span>()</span></span>{</span><br><br><span>IntReader reader;</span><br><span>reader.<span>BeginRead</span>([](<span>int</span>result) {</span><br><br><span>std::cout &lt;&lt; result &lt; std::endl;</span><br><span>});</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>假如我们需要调用多个 IntReader ，把它们的结果加起来再输出，那么基于回调的代码就会很难看了：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></pre></td><td><pre><span><span><span>void</span><span>PrintInt</span><span>()</span></span>{</span><br><br><span>IntReader reader1;</span><br><span>reader1.<span>BeginRead</span>([](<span>int</span>result1) {</span><br><br><span><span>int</span>total = result1;</span><br><br><span>IntReader reader2;</span><br><span>reader2.<span>BeginRead</span>([total](<span>int</span>result2) {</span><br><br><span>total += result2;</span><br><br><span>IntReader reader3;</span><br><span>reader3.<span>BeginRead</span>([total](<span>int</span>result3) {</span><br><br><span>total += result3;</span><br><span>std::cout &lt;&lt; total &lt;&lt; std::endl;</span><br><span>});</span><br><span>});</span><br><span>});</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>代码不仅需要一层套一层，还要在每层回调之间传递结果，这就是俗称的“回调地狱”。而有了协程，这些问题都迎刃而解，我们可以这样来调用<code>IntReader</code>：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></pre></td><td><pre><span><span>Task<span>PrintInt</span><span>()</span></span>{</span><br><br><span>IntReader reader1;</span><br><span><span>int</span>total =<span>co_await</span>reader1;</span><br><br><span>IntReader reader2;</span><br><span>total +=<span>co_await</span>reader2;</span><br><br><span>IntReader reader3;</span><br><span>total +=<span>co_await</span>reader3;</span><br><br><span>std::cout &lt;&lt; total &lt;&lt; std::endl;</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>代码逻辑顿时清晰了不少，看上去就像同步调用那样。在每一个调用 co_await 的地方，协程都会暂停下来，等 IntReader 操作完成之后再从这个地方恢复执行。接下来，我们来看下如何实现这种效果。</p><h2>4. 实现一个协程</h2><p>在C++中，只要在函数体内出现了<code>co_await</code>、<code>co_return</code>和<code>co_yield</code>这三个操作符中的其中一个，这个函数就成为了协程。我们先来关注一下<code>co_await</code>操作符。</p><h3>4.1. co_await 和 Awaitable</h3><p><code>co_await</code>的作用是让协程暂停下来，等待某个操作完成之后再恢复执行。在上面的协程示例中，我们对<code>IntReader</code>调用了<code>co_await</code>操作符，目前这是不可行的，因为<code>IntReader</code>是我们自定义的类型，编译器不理解它，不知道它什么时候操作完成，不知道如何获取操作结果。为了让编译器理解我们的类型，C++定义了一个协议规范，只要我们的类型按照这个规范实现好，就可以在<code>co_await</code>使用了。</p><p>这个规范称作 Awaitable，它定义了若干个函数，传给<code>co_await</code>操作符的对象必须实现这些函数。这些函数包括：</p><ul><li><p><code>await_ready()</code>，返回类型是<code>bool</code>。协程在执行<code>co_await</code>的时候，会先调用<code>await_ready()</code>来询问“操作是否已完成”，如果函数返回了<code>true</code>，协程就不会暂停，而是继续往下执行。实现这个函数的原因是，异步调用的时序是不确定的，如果在执行<code>co_await</code>之前就已经启动了异步操作，那么在执行<code>co_await</code>的时候异步操作有可能已经完成了，在这种情况下就不需要暂停，通过<code>await_ready()</code>就可以到达到这个目的。</p></li><li><p><code>await_suspend()</code>，有一个类型为<code>std::coroutine_handle&lt;&gt;</code>的参数，返回类型可以是<code>void</code>或者<code>bool</code>。如果<code>await_ready()</code>返回了<code>false</code>，意味着协程要暂停，那么紧接着会调用这个函数。该函数的目的是用来接收协程句柄（也就是<code>std::coroutine_handle&lt;&gt;</code>参数），并在异步操作完成的时候通过这个句柄让协程恢复执行。协程句柄类似于函数指针，它表示一个协程实例，调用句柄上的对应函数，可以让这个协程恢复执行。</p><p><code>await_suspend()</code>的返回类型一般为<code>void</code>，但也可以是<code>bool</code>，这时候的返回值用来控制协程是否真的要暂停，这里是第二次可以阻止协程暂停的机会。如果该函数返回了<code>false</code>，协程就不会暂停（注意返回值的含义跟<code>await_ready()</code>是相反的）。</p></li><li><p><code>await_resume()</code>，返回类型可以是<code>void</code>，也可以是其它类型，它的返回值就是<code>co_await</code>操作符的返回值。当协程恢复执行，或者不需要暂停的时候，会调用这个函数。</p></li></ul><p>接下来，我们修改一下 IntReader ，让它符合 Awaitable 规范。下面是完整的示例代码：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></pre></td><td><pre><br><br><br><br><span><span>class</span><span>IntReader</span>{</span><br><span><span>public</span>:</span><br><span><span><span>bool</span><span>await_ready</span><span>()</span></span>{</span><br><span><span>return</span><span>false</span>;</span><br><span>}</span><br><br><span><span><span>void</span><span>await_suspend</span><span>(std::coroutine_handle&lt;&gt; handle)</span></span>{</span><br><br><span>std::thread<span>thread</span><span>([<span>this</span>, handle]() {</span></span><br><br><span>std::srand(<span>static_cast</span>&lt;<span>unsigned</span><span>int</span>&gt;(std::time(<span>nullptr</span>)));</span><br><span>value_ = std::rand();</span><br><br><span>handle.resume();</span><br><span><span>})</span>;</span><br><br><span>thread.<span>detach</span>();</span><br><span>}</span><br><br><span><span><span>int</span><span>await_resume</span><span>()</span></span>{</span><br><span><span>return</span>value_;</span><br><span>}</span><br><br><span><span>private</span>:</span><br><span><span>int</span>value_{};</span><br><span>};</span><br><br><span><span>class</span><span>Task</span>{</span><br><span><span>public</span>:</span><br><span><span>class</span><span>promise_type</span>{</span><br><span><span>public</span>:</span><br><span><span>Task<span>get_return_object</span><span>()</span></span>{<span>return</span>{}; }</span><br><span><span>std::suspend_never<span>initial_suspend</span><span>()</span></span>{<span>return</span>{}; }</span><br><span><span>std::suspend_never<span>final_suspend</span><span>()</span><span>noexcept</span></span>{<span>return</span>{}; }</span><br><span><span><span>void</span><span>unhandled_exception</span><span>()</span></span>{}</span><br><span><span><span>void</span><span>return_void</span><span>()</span></span>{}</span><br><span>};</span><br><span>};</span><br><br><span><span>Task<span>PrintInt</span><span>()</span></span>{</span><br><br><span>IntReader reader1;</span><br><span><span>int</span>total =<span>co_await</span>reader1;</span><br><br><span>IntReader reader2;</span><br><span>total +=<span>co_await</span>reader2;</span><br><br><span>IntReader reader3;</span><br><span>total +=<span>co_await</span>reader3;</span><br><br><span>std::cout &lt;&lt; total &lt;&lt; std::endl;</span><br><span>}</span><br><br><span><span><span>int</span><span>main</span><span>()</span></span>{</span><br><br><span><span>PrintInt</span>();</span><br><br><span>std::string line;</span><br><span><span>while</span>(std::cin &gt;&gt; line) { }</span><br><span><span>return</span><span>0</span>;</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>我们先忽略返回类型<code>Task</code>，下文会专门介绍协程的返回类型。在这个例子中，对于<code>await_ready()</code>函数，我们总是返回 false，即协程总是要暂停。然后我们把子线程改成在<code>await_supsend()</code>中启动，也就是在协程暂停的时候来启动，因此不再需要<code>BeginRead()</code>函数了。子线程生成随机数之后，保存在<code>value_</code>成员变量中，然后调用协程句柄的<code>resume()</code>函数来恢复协程执行。最后通过<code>await_resume()</code>函数把结果返回给调用者。</p><p>值得关注的地方是线程的执行。在<code>main()</code>函数中，主线程调用了<code>PrintInt()</code>，执行到<code>co_await reader1</code>这一行，协程暂停了，于是主线程退出<code>PrintInt()</code>，返回到<code>main()</code>继续往下执行，最后在 while 循环中等待用户输入。接下来，在<code>reader1</code>中启动的子线程调用了协程句柄的<code>resume()</code>，所以从<code>co_await reader1</code>中恢复执行的是这个子线程，直到<code>co_await reader2</code>，协程再次暂停，子线程退出。以此类推，后面的流程分别由<code>reader2</code>和<code>reader3</code>中启动的子线程来继续执行。所以，在<code>PrintInt()</code>这个协程内，总共有四个线程参与了执行。这里的关键点是：哪个线程调用协程句柄的<code>resume()</code>，就由哪个线程恢复协程执行。建议在IDE中设置断点来观察这个示例程序的执行流程，以便更好地理解。</p><h3>4.2. 预定义的 Awaitable 类型</h3><p>C++预定义了两个符合 Awaitable 规范的类型：<code>std::suspend_never</code>和<code>std::suspend_always</code>。顾名思义，这两个类型分别表示“不暂停”和“要暂停”，实际上它们的区别仅在于<code>await_ready()</code>函数的返回值，<code>std::suspend_never</code>会返回 true，而<code>std::suspend_always</code>会返回 false。除此之外，这两个类型的<code>await_supsend()</code>和<code>await_resume()</code>函数实现都是空的。</p><p>这两个类型是工具类，用来作为<code>promise_type</code>部分函数的返回类型，以控制协程在某些时机是否要暂停。下文会详细介绍<code>promise_type</code>。</p><h3>4.3. 协程的返回类型和 promise_type</h3><p>现在我们把关注点聚焦在协程的返回类型上。C++对协程的返回类型只有一个要求：包含名为<code>promise_type</code>的内嵌类型。跟上文介绍的 Awaitable 一样，<code>promise_type</code>需要符合C++规定的协议规范，也就是要定义几个特定的函数。<code>promise_type</code>是协程的一部分，当协程被调用，在堆上为其状态分配空间的时候，同时也会在其中创建一个对应的<code>promise_type</code>对象。通过在它上面定义的函数，我们可以与协程进行数据交互，以及控制协程的行为。</p><p><code>promise_type</code>要实现的第一个函数是<code>get_return_object()</code>，用来创建协程的返回值。在协程内，我们不需要显式地创建返回值，这是由编译器隐式调用<code>get_return_object()</code>来创建并返回的。这个关系看起来比较怪异，<code>promise_type</code>是返回类型的内嵌类型，但编译器不会直接创建返回值，而是先创建一个<code>promise_type</code>对象，再通过这个对象来创建返回值。</p><img src="https://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/3.png"><p>那么协程的返回值有什么用呢？这取决于协程的设计者的意图，取决于他想要以什么样的方式来使用协程。例如，在上文的示例中，<code>PrintInt()</code>这个协程只是输出一个整数，不需要与调用者有交互，所以它的返回值只是一个空壳。 假如我们想实现一个<code>GetInt()</code>协程，它会返回一个整数给调用者，由调用者来输出结果，那么就需要对协程的返回类型做一些修改了。</p><h3>4.4. co_return</h3><p>我们现在把<code>PrintInt()</code>修改成<code>GetInt()</code>。使用<code>co_return</code>操作符可以从协程中返回数据，如下所示：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></pre></td><td><pre><span><span>Task<span>GetInt</span><span>()</span></span>{</span><br><br><span>IntReader reader1;</span><br><span><span>int</span>total =<span>co_await</span>reader1;</span><br><br><span>IntReader reader2;</span><br><span>total +=<span>co_await</span>reader2;</span><br><br><span>IntReader reader3;</span><br><span>total +=<span>co_await</span>reader3;</span><br><br><span><span>co_return</span>total;</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p><code>co_return total</code>这个表达式等价于<code>promise_type.return_value(total)</code>，也就是说，返回的数据会通过<code>return_value()</code>函数传递给<code>promise_type</code>对象，<code>promise_type</code>要实现这个函数才能接收到数据。除此之外，还要想办法让返回值<code>Task</code>能访问到这个数据。为了减少数据传递，我们可以在<code>promise_type</code>和<code>Task</code>之间共享同一份数据。修改之后的完整示例如下所示：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br></pre></td><td><pre><br><br><br><br><span><span>class</span><span>IntReader</span>{</span><br><span><span>public</span>:</span><br><span><span><span>bool</span><span>await_ready</span><span>()</span></span>{</span><br><span><span>return</span><span>false</span>;</span><br><span>}</span><br><br><span><span><span>void</span><span>await_suspend</span><span>(std::coroutine_handle&lt;&gt; handle)</span></span>{</span><br><br><span>std::thread<span>thread</span><span>([<span>this</span>, handle]() {</span></span><br><br><span>std::srand(<span>static_cast</span>&lt;<span>unsigned</span><span>int</span>&gt;(std::time(<span>nullptr</span>)));</span><br><span>value_ = std::rand();</span><br><br><span>handle.resume();</span><br><span><span>})</span>;</span><br><br><span>thread.<span>detach</span>();</span><br><span>}</span><br><br><span><span><span>int</span><span>await_resume</span><span>()</span></span>{</span><br><span><span>return</span>value_;</span><br><span>}</span><br><br><span><span>private</span>:</span><br><span><span>int</span>value_{};</span><br><span>};</span><br><br><span><span>class</span><span>Task</span>{</span><br><span><span>public</span>:</span><br><span><span>class</span><span>promise_type</span>{</span><br><span><span>public</span>:</span><br><span><span>promise_type</span>() :<span>value_</span>(std::<span>make_shared</span>&lt;<span>int</span>&gt;()) {</span><br><br><span>}</span><br><br><span><span>Task<span>get_return_object</span><span>()</span></span>{</span><br><span><span>return</span>Task{ value_ };</span><br><span>}</span><br><br><span><span><span>void</span><span>return_value</span><span>(<span>int</span>value)</span></span>{</span><br><span>*value_ = value;</span><br><span>}</span><br><br><span><span>std::suspend_never<span>initial_suspend</span><span>()</span></span>{<span>return</span>{}; }</span><br><span><span>std::suspend_never<span>final_suspend</span><span>()</span><span>noexcept</span></span>{<span>return</span>{}; }</span><br><span><span><span>void</span><span>unhandled_exception</span><span>()</span></span>{}</span><br><br><span><span>private</span>:</span><br><span>std::shared_ptr&lt;<span>int</span>&gt; value_;</span><br><span>};</span><br><br><span><span>public</span>:</span><br><span><span>Task</span>(<span>const</span>std::shared_ptr&lt;<span>int</span>&gt;&amp; value) :<span>value_</span>(value) {</span><br><br><span>}</span><br><br><span><span><span>int</span><span>GetValue</span><span>()</span><span>const</span></span>{</span><br><span><span>return</span>*value_;</span><br><span>}</span><br><br><span><span>private</span>:</span><br><span>std::shared_ptr&lt;<span>int</span>&gt; value_;</span><br><span>};</span><br><br><span><span>Task<span>GetInt</span><span>()</span></span>{</span><br><br><span>IntReader reader1;</span><br><span><span>int</span>total =<span>co_await</span>reader1;</span><br><br><span>IntReader reader2;</span><br><span>total +=<span>co_await</span>reader2;</span><br><br><span>IntReader reader3;</span><br><span>total +=<span>co_await</span>reader3;</span><br><br><span><span>co_return</span>total;</span><br><span>}</span><br><br><span><span><span>int</span><span>main</span><span>()</span></span>{</span><br><br><span><span>auto</span>task =<span>GetInt</span>();</span><br><br><span>std::string line;</span><br><span><span>while</span>(std::cin &gt;&gt; line) {</span><br><span>std::cout &lt;&lt; task.<span>GetValue</span>() &lt;&lt; std::endl;</span><br><span>}</span><br><span><span>return</span><span>0</span>;</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>我们在<code>promise_type</code>和<code>Task</code>之间，使用了<code>std::shared_ptr&lt;int&gt;</code>来共享数据。在<code>get_return_object()</code>中创建<code>Task</code>的时候，把<code>promise_type</code>里的智能指针传递了过去，这样它们就能访问到同一个数据。在<code>promise_type</code>的<code>return_value()</code>中写数据，然后在<code>Task</code>的<code>GetValue()</code>中读数据。</p><p>异步是具有传染性的，<code>GetInt()</code>内部调用了异步操作，所以它自身实际上也是一个异步操作。为了等待它执行完成，我们把<code>task.GetValue()</code>的调用放在了 while 循环中，每当用户输入一次之后就进行输出。由于这是一个简单的示例程序，没有各种高级的异步同步机制，所以通过等待用户输入方式来变相地等待协程执行完成。</p><p>在真实的使用场景中，协程的返回类型还需要提供各种同步机制才能给调用者使用，例如加上回调、通知等，就像普通的异步操作一样。由此可见，协程的优点体现在它内部的代码逻辑上，而不是对外的使用方式上。当然，我们也可以让协程的返回类型实现 Awaitable 规范，让它可以被另外一个协程更好地调用。这样一来，调用协程的也必须是协程，这样层层往上传递，直到遇到不能改成协程的函数为止，例如<code>main()</code>函数。从这个角度来说，协程也是具有传染性的。</p><p>最后，跟普通的<code>return</code>一样，<code>co_return</code>也可以不带任何参数，这时候协程以不带数据的方式返回，相当于调用了<code>promise_type.return_void()</code>，<code>promise_type</code>需要定义这个函数以支持不带数据的返回。如果我们在协程结束的时候没有调用任何<code>co_return</code>，那么编译器会隐式地加上一个不带参数的<code>co_return</code>调用。</p><h3>4.5. co_yield</h3><p>当协程调用了<code>co_return</code>，意味着协程结束了，就跟我们在普通函数中用<code>return</code>结束函数一样。这时候，与这个协程实例有关的内存都会被释放掉，它不能再执行了。如果需要在协程中多次返回数据而不结束协程的话，可以使用<code>co_yield</code>操作符。</p><p><code>co_yield</code>的作用是，返回一个数据，并且让协程暂停，然后等下一次机会恢复执行。<code>co_yield value</code>这个表达式等价于<code>co_await promise_type.yield_value(value)</code>，<code>co_yield</code>的参数会传递给<code>promise_type</code>的<code>yield_value()</code>函数，再把这个函数的返回值传给<code>co_await</code>。上文提到，传给<code>co_await</code>的参数要符合 Awaitable 规范，所以<code>yield_value()</code>的返回类型也要满足这个规范。在这里就可以使用预定义的<code>std::supsend_never</code>或<code>std::suspend_always</code>，通常会使用后者来让协程每次调用<code>co_yield</code>的时候都暂停。</p><p>下面我们修改一下示例，当用户输入一次之后，从协程取出一个值输出，然后让它生成下一个值；用户继续输入，又取出一个值输出，再生成下一个值，如此反复循环。完整的示例代码如下：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br></pre></td><td><pre><br><br><br><br><span><span>class</span><span>IntReader</span>{</span><br><span><span>public</span>:</span><br><span><span><span>bool</span><span>await_ready</span><span>()</span></span>{</span><br><span><span>return</span><span>false</span>;</span><br><span>}</span><br><br><span><span><span>void</span><span>await_suspend</span><span>(std::coroutine_handle&lt;&gt; handle)</span></span>{</span><br><br><span>std::thread<span>thread</span><span>([<span>this</span>, handle]() {</span></span><br><br><span><span>static</span><span>int</span>seed =<span>0</span>;</span><br><span>value_ = ++seed;</span><br><br><span>handle.resume();</span><br><span><span>})</span>;</span><br><br><span>thread.<span>detach</span>();</span><br><span>}</span><br><br><span><span><span>int</span><span>await_resume</span><span>()</span></span>{</span><br><span><span>return</span>value_;</span><br><span>}</span><br><br><span><span>private</span>:</span><br><span><span>int</span>value_{};</span><br><span>};</span><br><br><span><span>class</span><span>Task</span>{</span><br><span><span>public</span>:</span><br><span><span>class</span><span>promise_type</span>{</span><br><span><span>public</span>:</span><br><span><span>Task<span>get_return_object</span><span>()</span></span>{</span><br><span><span>return</span>Task{ std::coroutine_handle&lt;promise_type&gt;::<span>from_promise</span>(*<span>this</span>) };</span><br><span>}</span><br><br><span><span>std::suspend_always<span>yield_value</span><span>(<span>int</span>value)</span></span>{</span><br><span>value_ = value;</span><br><span><span>return</span>{};</span><br><span>}</span><br><br><span><span><span>void</span><span>return_void</span><span>()</span></span>{ }</span><br><span><span>std::suspend_never<span>initial_suspend</span><span>()</span></span>{<span>return</span>{}; }</span><br><span><span>std::suspend_never<span>final_suspend</span><span>()</span><span>noexcept</span></span>{<span>return</span>{}; }</span><br><span><span><span>void</span><span>unhandled_exception</span><span>()</span></span>{}</span><br><br><span><span><span>int</span><span>GetValue</span><span>()</span><span>const</span></span>{</span><br><span><span>return</span>value_;</span><br><span>}</span><br><br><span><span>private</span>:</span><br><span><span>int</span>value_{};</span><br><span>};</span><br><br><span><span>public</span>:</span><br><span><span>Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) :<span>coroutine_handle_</span>(handle) {</span><br><br><span>}</span><br><br><span><span><span>int</span><span>GetValue</span><span>()</span><span>const</span></span>{</span><br><span><span>return</span>coroutine_handle_.<span>promise</span>().<span>GetValue</span>();</span><br><span>}</span><br><br><span><span><span>void</span><span>Next</span><span>()</span></span>{</span><br><span>coroutine_handle_.<span>resume</span>();</span><br><span>}</span><br><br><span><span>private</span>:</span><br><span>std::coroutine_handle&lt;promise_type&gt; coroutine_handle_;</span><br><span>};</span><br><br><span><span>Task<span>GetInt</span><span>()</span></span>{</span><br><br><span><span>while</span>(<span>true</span>) {</span><br><br><span>IntReader reader;</span><br><span><span>int</span>value =<span>co_await</span>reader;</span><br><span><span>co_yield</span>value;</span><br><span>}</span><br><span>}</span><br><br><span><span><span>int</span><span>main</span><span>()</span></span>{</span><br><br><span><span>auto</span>task =<span>GetInt</span>();</span><br><br><span>std::string line;</span><br><span><span>while</span>(std::cin &gt;&gt; line) {</span><br><br><span>std::cout &lt;&lt; task.<span>GetValue</span>() &lt;&lt; std::endl;</span><br><span>task.<span>Next</span>();</span><br><span>}</span><br><span><span>return</span><span>0</span>;</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>这个示例修改的点比较多，我们拆解来看。首先，为了方便看出来程序的确是按照我们的预期来运行的，这里把<code>IntReader::await_suspend()</code>子线程内生成随机整数改成生成递增的整数。</p><p>然后，为了让使用者可以恢复协程执行，<code>Task</code>增加了一个<code>Next()</code>函数，这个函数调用了作为成员变量的协程句柄来恢复执行：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span><span>void</span><span>Next</span><span>()</span></span>{</span><br><span>coroutine_handle_.<span>resume</span>();</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>这意味着<code>Task</code>需要拿到协程的句柄，这是在<code>promise_type</code>的<code>get_return_object()</code>中通过以下方式传递过去的：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span>Task<span>get_return_object</span><span>()</span></span>{</span><br><span><span>return</span>Task{ std::coroutine_handle&lt;promise_type&gt;::<span>from_promise</span>(*<span>this</span>) };</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p><code>std::coroutine_handle</code>的<code>from_promise()</code>函数可以通过<code>promise_type</code>对象获取与之关联的协程句柄，反之，协程句柄上也有一个<code>promise()</code>函数可以获取对应的<code>promise_type</code>对象，他们是可以互相转换的。所以，在<code>Task</code>和<code>promise_type</code>之间就不需要使用<code>std::shared_ptr&lt;int&gt;</code>来共享数据了，<code>Task</code>通过协程句柄就能访问到<code>promise_type</code>对象，像下面这样直接取数据就可以了：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span><span><span>int</span><span>GetValue</span><span>()</span><span>const</span></span>{</span><br><span><span>return</span>coroutine_handle_.<span>promise</span>().<span>GetValue</span>();</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>这里要注意一下协程句柄<code>std::coroutine_handle</code>的模板类型。在前面的例子中，协程句柄的类型是<code>std::coroutine_handle&lt;&gt;</code>，不带模板参数；而在这个例子中，协程句柄的类型是<code>std::coroutine_handle&lt;promise_type&gt;</code>，模板参数中填入了<code>promise_type</code>类型。它们的区别类似于指针<code>void*</code>和<code>promise_type*</code>的区别，前者是无类型的，后者是强类型的。两种类型的协程句柄本质上是相同的东西，它们可以有相同的值，指向同一个协程实例，而且也都可以恢复协程执行。但只有强类型的<code>std::coroutine_handle&lt;promise_type&gt;</code>才能调用<code>from_promise()</code>获取到<code>promise_type</code>对象。</p><p>接下来，协程<code>GetInt()</code>的实现修改成一个无限循环，在循环内通过<code>IntReader</code>获取到整数，再通过<code>co_yield</code>把整数返回出去：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></pre></td><td><pre><span><span>Task<span>GetInt</span><span>()</span></span>{</span><br><br><span><span>while</span>(<span>true</span>) {</span><br><br><span>IntReader reader;</span><br><span><span>int</span>value =<span>co_await</span>reader;</span><br><span><span>co_yield</span>value;</span><br><span>}</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>对于协程来说，无限循环是常见的实现方式，由于它具有暂停的特性，并不会像普通函数那样让线程在里面死循环。</p><p>最后，在<code>promise_type</code>中定义了<code>yield_value()</code>函数来接收<code>co_yield</code>返回的数据。我们希望返回数据之后立即暂停协程，所以返回类型定义成了<code>std::supsend_always</code>。</p><h3>4.6. 协程的生命周期</h3><p>正如上文所说的，在一开始调用协程的时候，C++会在堆上为协程的状态分配内存，这块内存必须在适当的时机来释放，否则就会造成内存泄漏。释放协程的内存有两种方式：自动释放和手动释放。</p><p>当协程结束的时候，如果我们不做任何干预，那么协程的内存就会被自动释放。调用了<code>co_return</code>语句之后，协程就会结束，下面两个协程是自动释放的例子：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></pre></td><td><pre><span><span>Task<span>GetInt</span><span>()</span></span>{</span><br><br><span>IntReader reader;</span><br><span><span>int</span>value =<span>co_await</span>reader;</span><br><br><span><span>co_return</span>value;</span><br><span>}</span><br><br><br><span><span>Task<span>PrintInt</span><span>()</span></span>{</span><br><br><span>IntReader reader1;</span><br><span><span>int</span>value =<span>co_await</span>reader;</span><br><br><span>std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p><code>PrintInt()</code>没有出现<code>co_return</code>语句，编译器会在末尾隐式地加上<code>co_return</code>。</p><p>自动释放的方式有时候并不是我们想要的，参考下面这个例子：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></pre></td><td><pre><br><br><br><br><span><span>class</span><span>Task</span>{</span><br><span><span>public</span>:</span><br><span><span>class</span><span>promise_type</span>{</span><br><span><span>public</span>:</span><br><span><span>Task<span>get_return_object</span><span>()</span></span>{</span><br><span><span>return</span>Task{ std::coroutine_handle&lt;promise_type&gt;::<span>from_promise</span>(*<span>this</span>) };</span><br><span>}</span><br><br><span><span><span>void</span><span>return_value</span><span>(<span>int</span>value)</span></span>{</span><br><span>value_ = value;</span><br><span>}</span><br><br><span><span><span>int</span><span>GetValue</span><span>()</span><span>const</span></span>{</span><br><span><span>return</span>value_;</span><br><span>}</span><br><br><span><span>std::suspend_never<span>initial_suspend</span><span>()</span></span>{<span>return</span>{}; }</span><br><span><span>std::suspend_never<span>final_suspend</span><span>()</span><span>noexcept</span></span>{<span>return</span>{}; }</span><br><span><span><span>void</span><span>unhandled_exception</span><span>()</span></span>{}</span><br><br><span><span>private</span>:</span><br><span><span>int</span>value_{};</span><br><span>};</span><br><br><span><span>public</span>:</span><br><span><span>Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) :<span>coroutine_handle_</span>(handle) {</span><br><br><span>}</span><br><br><span><span><span>int</span><span>GetValue</span><span>()</span><span>const</span></span>{</span><br><span><span>return</span>coroutine_handle_.<span>promise</span>().<span>GetValue</span>();</span><br><span>}</span><br><br><span><span>private</span>:</span><br><span>std::coroutine_handle&lt;promise_type&gt; coroutine_handle_;</span><br><span>};</span><br><br><span><span>Task<span>GetInt</span><span>()</span></span>{</span><br><br><span><span>co_return</span><span>1024</span>;</span><br><span>}</span><br><br><span><span><span>int</span><span>main</span><span>()</span></span>{</span><br><br><span><span>auto</span>task =<span>GetInt</span>();</span><br><br><span>std::string line;</span><br><span><span>while</span>(std::cin &gt;&gt; line) {</span><br><span>std::cout &lt;&lt; task.<span>GetValue</span>() &lt;&lt; std::endl;</span><br><span>}</span><br><span><span>return</span><span>0</span>;</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，<code>GetInt()</code>协程通过<code>co_return</code>返回了1024给<code>promise_type</code>；协程返回值<code>Task</code>通过协程句柄访问<code>promise_type</code>，从中取出这个值。随着用户的输入，把这个值输出来。运行程序，我们会发现输出的值并不是1024，而是一个随机值；也有可能会出现地址访问错误的异常。</p><p>造成这个现象的原因是，协程在返回1024之后就被自动释放了，<code>promise_type</code>也跟着被一起释放了，此时在<code>Task</code>内部持有的协程句柄已经变成了野指针，指向一块已经被释放的内存。所以访问这个协程句柄的任何行为都会造成不确定的后果。</p><p>解决这个问题的方法是，修改<code>promise_type</code>中<code>final_supsend()</code>函数的返回类型，从<code>std::suspend_never</code>改成<code>std::suspend_always</code>。协程在结束的时候，会调用<code>final_suspend()</code>来决定是否暂停，如果这个函数返回了要暂停，那么协程不会自动释放，此时协程句柄还是有效的，可以安全访问它内部的数据。</p><p>不过，这时候释放协程就变成我们的责任了，我们必须在适当的时机调用协程句柄上的<code>destroy()</code>函数来手动释放这个协程。在这个例子中，可以在<code>Task</code>的析构函数中做这个事情：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br></pre></td><td><pre><span>~<span>Task</span>() {</span><br><span>coroutine_handle_.<span>destroy</span>();</span><br><span>}</span><br></pre></td></tr></tbody></table></figure><p>只要协程处于暂停状态，就可以调用协程句柄的<code>destroy()</code>函数来释放它，不一定要求协程结束。对于通过无限循环来实现的协程，手动释放是必需的。</p><p>与<code>final_suspend()</code>相对应的是<code>initial_suspend()</code>，在协程刚开始执行的时候，会调用这个函数来决定是否暂停。我们可以将这个函数的返回类型改成<code>std::suspend_always</code>来让协程一执行即暂停。这对于一些需要延迟执行的场景是有用的，例如，我们想先获取一批协程句柄，像数据那样对它们进行管理，在稍后的时机再挑选合适的协程来执行。</p><h3>4.7. 异常处理</h3><p>最后，我们看一下协程的异常处理。编译器生成的执行协程的伪代码大概如下所示：</p><figure><table><tbody><tr><td><pre><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></pre></td><td><pre><span><span>try</span>{</span><br><br><span><span>co_await</span>promise_type.<span>initial_suspend</span>();</span><br><br><br><span>}</span><br><span><span>catch</span>(...) {</span><br><br><span>promise_type.<span>unhandled_exception</span>();</span><br><span>}</span><br><br><span><span>co_await</span>promise_type.<span>final_suspend</span>();</span><br></pre></td></tr></tbody></table></figure><p>协程主要的执行代码都被 try - catch 包裹，假如抛出了未处理的异常，<code>promise_type</code>的<code>unhandled_exception()</code>函数会被调用，我们可以在这个函数里面做对应的异常处理。由于这个函数是在<code>catch</code>语句中调用的，我们可以在函数内调用<code>std::current_exception()</code>函数获取异常对象，也可以调用<code>throw</code>重新抛出异常。</p><p>调用了<code>unhandled_exception()</code>之后，协程就结束了，接下来会继续调用<code>final_suspend()</code>，与正常结束协程的流程一样。C++规定<code>final_suspend()</code>必须定义成<code>noexcept</code>，也就是说它不允许抛出任何异常。</p><h2>5. 后记</h2><p>至此，关于C++协程的基础内容介绍完毕。从当前的使用方式来看，C++20的协程只提供了最基础的能力，为了用上它，我们需要写不少代码，将一个一个小块串联起来。所以，现在C++协程的形态是不友好的，晦涩难懂，难以学习。</p><p>要想在实际的开发中使用上C++协程，还有比较长的路。我们可以自己动手对它进行封装，或者寻求第三方库的解决方案，或者继续期待未来的C++标准带来更高层封装的协程组件。</p></div></div>
        </div>
        
    </div>




</body></html>